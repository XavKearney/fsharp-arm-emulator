# Xav Kearney
This documentation covers how the `MultMem` module works, including the main source file `MultMem.fs`, as well as the corresponding tests in `MultMemTests.fs`. It also includes some comments on the general purpose expression parser implemented in the `ParseExpr` module, as well as the `VisualTesting` framework which has been modified to allow for property-based testing of memory instructions against [VisUAL](https://salmanarif.bitbucket.io/visual/).

## Contributions to Group
This code fully implements the following instructions:
- `LDM`
- `STM`
- `B/BL`
- `END`

The `LDM/STM` instructions contain numerous different parameters, and as such are difficult to test thoroughly. For robustness, they have been tested against `VisUAL` using randomised data for 500,000 iterations. This was only possible by modifying the supplied `VisualTesting` framework to enable memory initialisation.

For the `B/BL` instructions, I wrote a general-purpose parser to evaluate expressions (contained in the `ParseExpr` module). This supports exactly the same expression syntax as VisUAL (with labels, brackets, arithmetic and numbers in different forms) and so should be able to be utilised throughout the group project wherever expressions are used.

To maximise compatibility, the majority of the code is based on the standard interfaces defined in the `CommonData` and `CommonLex` modules, used by the whole team. Before beginning on the individual proportion of the work, we liaised as a group to set out a standard project structure which is followed here.

The main interface to the `MultMem` module is via the `parse` function, which takes `LineData` and outputs a parsed instruction if the instruction is handled by the module and is valid. The result of the `parse` function can then be fed to the `execInstr` function which returns the correct function to be executed for any given instruction in the module.

## Table of Features
| Instruction/s | Feature | Tested?|  
|:---:|:---|:---:|:---|
| `LDM/STM` | All 4 direction suffixes | ✔️    |
| `LDM/STM` | All aliases | ✔️    |
| `LDM/STM` | Register list as range (e.g. `R0-R5`) | ✔️    |
| `LDM/STM` | Write-back suffix | ✔️    |
| `LDM/STM` | Registers sorted in increasing order | ✔️    |
| `LDM/STM` | All ARM restrictions | ✔️    |
| `LDM/STM` | Descriptive error messages, no exceptions | ✔️    |
| `B/BL` | VisUAL-style expression parsing with labels | ✔️    |
| `B/BL` | Descriptive error messages, no exceptions | ✔️    |
| `END` | Implemented | ✔️    |
| `All` | Universal parse and execution functions. | ✔️    |

Below is a description of the testing, as well as notable differences from VisUAL. After this there is a more complete explanation of the instruction operation, inteded as a README for the module (rather than as part of the deliverable).

## Testing
### LDM & STM
#### Parsing
The `parseMemOps` function is tested with a series of unit tests (`parseOps Unit`) to determine correct operation both for simple, valid instructions and also for invalid instructions where the expected output is the correct error message.

A number of unit tests (`parse Unit-MultMem`) are also used to check that the `parse` function correctly returns errors when the input corresponds to ARM restrictions.

The more thorough testing occurs in the completely randomised property-based test defined within `testParse`. This generates `LineData` based on randomly generated parameters, including randomly chosen aliases, and then the expected result after parsing is generated by matching the randomly generated parameters to determine if they are valid. Every possible expected result is covered by the match, and the property test is run 10,000 times.

#### Execution
Initially, manually tests were performed to confirm that the `execMultMem` function correctly modifies CPU state according to the ARM specification.

However, for maximum robustness, a property-based test is used to compare the effect of a random instruction on CPU state with the CPU state after the same instruction is processed by VisUAL. This is achieved with the help of a `VisualTesting` framework, written by [Dr. Tom Clarke](https://intranet.ee.ic.ac.uk/electricalengineering/eepeople/person.asp?s=NIL&id=75) and adapted into a package, with some minor modifications to allow initialised memory based on a `Map`, by me (Xav Kearney).

This property-based test randomly generates both initial CPU state (registers, memory and flags) and also the instruction parameters. The random parameters are first checked to see if they conform to the restrictions set both by ARM (as above) and VisUAL (see below). If not, the test is skipped. If the parameters are valid they are converted into the forms used by both `MultMem.fs` and VisUAL (which differ slightly due to types), and the results are compared. Some sorting is required to transform the resulting VisUAL register & memory state into the same form as the result of `execMultMem`.

If no errors are returned, the register contents, memory address data and flags are all checked for equality to consider a test passed. By default 10,000 tests are run (although the actual test number is much lower given the validity constraints). Increasing this to 500,000 takes over an hour to run and results in a 100% pass rate.

### B & BL
#### Parsing
The parsing of the `B/BL` instructions is tested with a series of unit tests, of both the `makeBranchInstr` function and the top-level `parse` function.

There is no randomised testing of these instructions as randomly generating valid mathematical expressions involving arbitrary labels is non-trivial and provides little extra benefit given that the `evalExpr` function is separately tested.

#### Execution
Execution of the `B/BL` instructions is tested using a property-based test with randomised `cpuData` (registers, flags and memory) and also randomised `branchAddr` and `linkAddr` fields. 

This cannot be tested against VisUAL because branching to a random instruction location would break in the test code. As a result, the returned modified `cpuData` is checked to ensure its registers, memory and flags equal the expected values in the case of both `B` and `BL`.

#### Differences from VisUAL
In testing, a number of differences from VisUAL were discovered:
1. VisUAL does not allow `LDM/STM` instructions without a suffix, e.g. `LDM R0, {R1}`. 
   - These instructions are excluded from randomised testing against VisUAL, but allowed by both the parsing and execution functions because it is a trivial difference, conforms to the ARM spec, and allows easier, more readable code to be written.
2. VisUAL does not allow `LDM/STM` instructions to access memory space below `0x1000`, which is reserved for code.
   - Tests are limited to a starting memory address above `0x1030` (to allow instructions which decrement by up to `0x30`)
   - This restriction does not apply to this F# implementation. Memory locations can be set as `Code` or as `DataLoc` types, and this distinction is handled within the execution; accessing a `Code` memory location throws an error.
3. VisUAL does not allow the target register to be within the register list, even when the writeback suffix is not used.
    - This restriction makes sense within the educational context of VisUAL. However, this module aims to adhere to the ARM specification as closely as possible, and so allows the target register to be within the register list provided the writeback suffix is not used.
4. VisUAL requires memory addresses to be divisible by 4.
    - This is not a restriction used by the `MultMem` module, but the module does incremement addresses by 4 so that the addresses can be considered as referring to bytes, to maximise compatibility with VisUAL. This memory model may change during the group phase if it allows for better error checking.
4. It is not possible to test with register lists larger than 12 registers as a result of the `VisualTesting` framework. This is because the memory addresses are loaded into registers.
5. It is not possible to test when `R15` is modified by an `LDM/STM` instruction against VisUAL because loading a value into `R15` causes the test code to branch to an unwanted instruction location.
6. VisUAL instructions are case-insensitive. This module assumes upper-case instructions, and the intention is that the top-level code in the group phase of the project will convert instructions to upper-case to allow case insensitivity.
7. VisUAL throws a Java exception if a reverse-ordered register list is given, e.g. `LDM R0, {R5-R1}`. The `MultMem` module handles this case, returning an Error within a Result monad.

## Module Implementation Specifics

### LDM - Load Multiple Registers
`LDM` is ARM's _Load Multiple Registers_ instruction. It has the syntax:

```LDM[dir]{cond} source[!], {list of registers}```

An example command would be: `LDM R0, {R3,R7,R9}`. As in VisUAL, contiguous register ranges can be supplied with the shorthand form e.g. `{R0-R9}`.

The registers in the `{list of registers}` are loaded with the word values of memory addresses based on the value of the `source` register. The optional `!` indicates whether to write-back the value of the final memory location to the source. The `dir` (direction) optional suffix indicates how the source memory addresses are calculated based on this value, and takes one of following forms:

| Direction | Aliases       | Effect                             |
| --------- | :-----------: | :--------------------------------: |
| `""`      | `"FD"`, `IA"` | Full Descending (Increment After)  |
| `"EA"`    | `"DB"`        | Empty Ascending (Decrement Before) |
| `"FA"`    | None          | Full Ascending                     |
| `"ED"`    | None          | Empty Descending                   |

_Ascending_ instructions decrease the memory address with each load. _Descending_ does the opposite.
_Empty_ instructions increment the memory address in the `source` register before any data is loaded. `Full` instructions do the opposite. The register list is **always** accessed in order of increasing register numbers (i.e. `R0` before `R1`).

The following restrictions apply to `LDM` instructions:
- The `source` register must not be `PC`.
- The register list must not contain `SP`.
- The register list must not contain `PC` if it contains `LR`.
- If write-back is specified, the register list must not contain the `source` register.
### STM - Store Multiple Registers
`STM` is ARM's _Store Multiple Registers_ instruction, essentially the opposite to `LDM`. It has the syntax:

```STM[dir]{cond} dest[!], {list of registers}```

An example command would be: `STM R0, {R3,R7,R9}`. As in VisUAL, contiguous register ranges can be supplied with the shorthand form e.g. `{R0-R9}`.

The word values of the registers in the `{list of registers}` are stored in the memory addresses based on the value of the `dest` (destination) register. The optional `!` indicates whether to write-back the value of the final memory location to the destination register. 

The `dir` (direction) optional suffix indicates how the source memory addresses are calculated based on this value, and takes one of following forms (NB: different to `LDM`):

| Direction | Aliases       | Effect                             |
| --------- | :-----------: | :--------------------------------: | 
| `""`      | `"EA"`, `IA"` | Empty Ascending (Increment After)  |
| `"FD"`    | `"DB"`        | Full Descending (Decrement Before) |
| `"FA"`    | None          | Full Ascending                     |
| `"ED"`    | None          | Empty Descending                   |

 _Ascending_ instructions increase the memory address with each load. _Descending_ does the opposite.
_Empty_ instructions increment the memory address in the `dest` register after data is loaded. `Full` instructions do the opposite. The register list is always accessed in order of increasing register numbers (i.e. `R0` before `R1`).

The following restrictions apply for `STM` instructions:
- The `dest` register must not be `PC`.
- The register list must not contain `SP` or `PC`.
- If write-back is specified, the register list must not contain the `dest` register.

### B/BL - Branch/Branch with Link
Branch instructions change the program counter, allowing program execution to jump immediately to any given memory address (which normally represents an instruction). They have the syntax:

```B[L]{cond} target```

The optional `L` suffix is used to indicate whether to write the address of the next instruction (after the branch instruction) to the link register (`LR`).

The `target` can be any expression involving numeric literals, which can be any of:
- Standard integer numbers of the form `[0-9]+`
- Hexadecimal numbers of the forms `0x[a-fA-F0-9]+` or `&[a-fA-F0-9]+`
- Binary numbers of the form `0b[0-1]+`

The expression can also include labels which correspond to addresses, the mapping of which is stored in the `SymTab` record of the `LineData`. The elements in the expression can be combined with any valid mathematical combination of brackets, multiplication, addition and subtraction. The result conforms to the standard `BODMAS` rules.

### END
The `END` instruction is used to (conditionally) terminate program execution. It has the simple syntax:

`END{cond}`

No other information is encoded, and its 'execution' is handled by the top-level code so is not covered further here. 

## Implementation
The following details how the above instructions are implemented in the `MultMem` module.

The expected entry-point to the module code is the `parse` function which first determines whether some given `LineData` corresponds to an opcode that the `MultMem` module handles. These are determined from a combination of the `multMemSpec`, `branchSpec` and `endSpec`, which together define the roots and possible suffixes of all the opcodes handled.
### LDM & STM
#### Parsing
 If an instruction is handled by `MultMem` and is of instruction class `MEM` (in this context, either an `LDM` or `STM` instruction) then the root, suffix and operands of the instruction are processed by the `makeMultMemInstr` function.

`makeMultMemInstr` first calls a `parseMemOps` function to convert the operands string into a target register (either source or destination), a boolean for whether to write-back, and a list of `RName`s corresponding to the register list. This is achieved by first splitting the operands string by `,` to determine the target register, and then checking to see if the string ends with `!` (indicating a write-back suffix). The register list is then recombined and processed into a list of `RName`s using regular expression-based active pattern matching.

The `MultMemInstr` type includes all parameters required to execute any valid `LDM/STM` instruction, given CPU state in the form of a `DataPath`.

An error at any stage has a corresponding error message which bubbles up to the original call. A function `checkValid` ensures that the resulting parsed `MultMemInstr` adheres to the restrictions detailed above before returning the `MultMemInstr` wrapped in a `Result` monad.

#### Execution
Execution is performed by the `execMultMem` function, which is passed a parsed `MultMemInstr` as a parameter, along with CPU state in the form of a `DataPath`. 

First, the relevant data from the `MultMemInstr` is extracted and the `checkValid` instruction is used again to ensure validity. The register list is sorted, the initial memory address determined and the direction embedded into a function `dirOp` which performs either addition or subtraction. The list of registers is then recursively traversed and adjusts the given `DataPath` accordingly. The result is either an `Error (string)`, or the modified `cpuData` wrapped in a `Result` monad.

### B/BL
### Parsing
Parsing the `B/BL` instructions requires a `SymbolTable` to correctly determine the addresses corresponding to labels in the given expression. If the `makeBranchInstr` is called without a `SymbolTable`, the result is a `BranchInstr` with both fields (`BranchAddr` and `LinkAddr`) set to `None`.

Given a `SymbolTable`, the `makeBranchInstr` uses the `ParseExpr` module's `evalExpr` function to evaluate the expression included in the operands. If the expression is valid, the result is returned in the `branchAddr` field of the result. If not valid, an `Error` is returned.

If the `L` suffix is supplied, the `linkAddr` field is set to the current instruction's `LoadAddr+4`. If not, the field is `None`.

### Execution
The `execBranchInstr` takes a parsed `BranchInstr` and valid `DataPath`, returning a modified `DataPath` corresponding to the instruction execution's effect.

If the `LinkAddr` is not set, the returned `DataPath` simply has its `PC` (`R15`) register set to the value of `branchAddr`. If it is set, then in addition to this, the `LR` (`R14`) register is set to the value of `LinkAddr`.

In any other case, an error is returned.


